# SO_exercicios

  # Programação concorrente e multiprogramação
  
   > Programação concorrente:
   
Do inglês Concurrent Programming, onde Concurrent significa “acontecendo ao mesmo tempo”. 
	</p>  <p> * É um paradigma de programação para a construção de programas de computador que fazem uso da execução concorrente (simultânea) de várias tarefas computacionais interativas, que podem ser implementadas como programas separados ou como um conjunto de threads criadas por um único programa 
	</p>  <p> * É diferente de computação paralela! Fio, linha, fluxo
	</p>  <p> * A programação concorrente foi usada inicialmente na construção de sistemas operacionais 
	</p>  <p> * Atualmente, ela é usada para desenvolver aplicações em todas as áreas da computação 
	</p>  <p> * Este tipo de programação tornou-se ainda mais importante com o advento dos sistemas distribuídos e das máquinas com arquitetura paralela
	</p>  <p> * Tradicionalmente, a grande maioria dos programas escritos são programas sequenciais – Para serem executados em um único computador com uma única CPU – O problema é dividido em uma série de instruções que são executadas uma após a outra – Uma única instrução pode ser executada em um determinado instante de tempo 
	</p>  <p> * Nesse caso, existe somente um fluxo de controle (fluxo de execução, linha de execução, thread) no programa 
	</p>  <p> * Isso permite, por exemplo, que o programador realize uma "execução imaginária" de seu programa apontando com o dedo, a cada instante, o comando que está sendo executado no momento
	</p>  <p> * Um programa concorrente pode ser visto como se tivesse vários fluxos de execução – Para o programador realizar agora uma "execução imaginaria", ele vai necessitar de vários dedos, um para cada fluxo de controle – Em programação concorrente é definido o uso simultâneo de múltiplos recursos computacionais para resolver um problema 
	</p>  <p> * Para ser executado em diversas CPUs: – O problema é quebrado em partes que podem ser executadas (resolvidas) concorrentemente – Cada uma destas partes é representada por uma série de instruções, sendo que as instruções de cada parte são executadas concorrentemente em diferentes CPUs
	</p>  <p> * É comum em sistemas multiusuário que um mesmo programa seja executado simultaneamente por vários usuários: – Por exemplo, um editor de texto – Entretanto, ter 10 execuções simultâneas do editor de texto não faz dele um programa concorrente – o que se tem são 10 processos independentes executando o mesmo programa sequencial (compartilhando o mesmo código) – Cada processo tem a sua área de dados e ignora a existência das outras execuções do programa – Esses processos não interagem entre si (não trocam informações) – Neste caso, é usado o termo programação paralela, pois vários programas/processos independentes são executados em paralelo pelo computador 
	</p>  <p> * Um programa é considerado concorrente quando ele (o próprio programa, durante a sua execução) origina diferentes processos que irão interagir entre si para realizar alguma tarefa
	</p>  <p> * Paralelismo – Processamento simultâneo físico 
	</p>  <p> * Concorrência – Processamento simultâneo lógico (aparente) – Requer entrelaçamento (interleaving) de ações 
	</p>  <p> * Processo – Execução de um programa 
	</p>  <p> * Programa Concorrente – Vários processos que cooperam para a realização de uma tarefa
	</p>  <p> * Um único computador com múltiplos processadores 
	</p>  <p> * Um número arbitrário de computadores conectados pela rede 
	</p>  <p> * Uma combinação de ambos (múltiplos computadores, com múltiplos processadores, conectados pela rede)
	</p>  <p> * O problema computacional geralmente demonstra características como a habilidade de ser: – Quebrados em partes de um trabalho que pode ser resolvido de forma simultânea – Executar múltiplas instruções do programa a qualquer momento no tempo – Resolvido em menos tempo com vários recursos de computação do que com um único recurso computacional
	</p>  <p> * Programação concorrente é mais complexa do que a programação sequencial: – Erros dos programas sequenciais + erros associados as interações entre os processos – Erros dependem do momento exato em que o escalonador do SO realiza um chaveamento de contexto ou do recebimento de uma mensagem – Difícil reprodução e identificação
	</p>  <p> * Apesar da maior complexidade, existem muitas áreas nas quais a programação concorrente é vantajosa: – Em sistemas nos quais existem vários processadores (máquinas paralelas ou sistemas distribuídos), é possível aproveitar esse paralelismo e acelerar a execução do programa – Mesmo em sistemas com um único processador, existem razões para o seu uso em vários tipos de aplicações

  > Exemplo 
	</p>  <p> * O uso da programação concorrente é natural nas aplicações que apresentam paralelismo intrínseco, ditas aplicações inerentemente paralelas – Nessas aplicações pode-se distinguir facilmente funções para serem realizadas em paralelo – Este é o caso do spooling de impressão, exemplo que será apresentado a seguir 
	</p>  <p> * Pode-se dizer que, em geral, a programação concorrente tem aplicação natural na construção de sistemas que tenham de implementar serviços que são requisitados de forma imprevisível – Nesse caso, o programa concorrente terá um processo para realizar cada tipo de serviço

  > Vantagens 
	</p>  <p> * Economizar tempo e dinheiro </p>  <p> * Resolver grandes problemas – Muitos problemas são tão grandes/complexos que é impraticável ou impossível resolvê-los num único computador, especialmente quando a memória é limitada </p>  <p> * Superar as limitações da computação sequencial: – razões físicas e práticas restringem a construção de computadores cada vez mais rápidos </p>  <p> * Arquiteturas de computadores atuais são cada vez mais dependentes do paralelismo em nível de hardware para melhorar o desempenho
	</p>  <p> * Quando iniciamos uma aplicação, o fluxo principal de execução, muitas vezes assume múltiplas responsabilidades sequencialmente, dependendo das ações que pedimos para realizar: – Receber entrada de um usuário, ler um arquivo, executar alguns cálculos, acessar um serviço web, atualizar um banco de dados, exibir uma resposta ao usuário, e assim por diante </p>  <p> * Se cada uma dessas operações leva apenas frações de segundo, então pode não haver necessidade real para introduzir fluxos adicionais de execução – Um único fluxo pode ser adequado para atender às necessidades
 </p>  <p> * Em aplicações não triviais, no entanto, essas operações podem não ser tão rápidas: – Cálculos podem levar de alguns segundos até alguns minutos – Os pedidos de dados a um serviço web pode encontrar atrasos de rede, de modo que o fluxo deve aguardar a resposta para chegar – Enquanto isso está acontecendo, não há nenhuma maneira dos usuários do aplicativo interagirem com, ou interromperem a aplicação, porque um único fluxo é executado até que a operação termine </p>  <p> * Concorrência pode não só ajudar a tornar as aplicações mais ágeis, como também podem ajudar a melhorar a experiência do usuário – Os aplicativos podem olhar para frente em operações que o usuário poderá realizar no próximo passo e realizar as ações necessárias, como indexação ou cache de alguns dados de que o usuário precisa
 </p>  <p> * Supondo que estamos encarregados de construir um aplicativo que precisa processar lotes de notas fiscais de vários fornecedores </p>  <p> * Isso exige que nós apliquemos regras e fluxo de trabalho em cada fatura, mas podemos processá-las em qualquer ordem </p>  <p> * O processamento dessas faturas sequencialmente não vai aproveitar a taxa de transferência ou utilizar os recursos disponíveis </p>  <p> * Nossa aplicação precisa processar essas faturas simultaneamente
 </p>  <p> * Utilizar mais de um computador ou um computador com mais de um processador, para resolver um determinado problema – N computadores operando simultaneamente podem atingir o resultado N vezes mais rápido (não será exatamente N vezes mais rápidos por uma série de razões) </p>  <p> * Outros motivos incluem: – Tolerância a falhas, grande quantidade de memória disponível, redução da latência, etc.
  > Perigos da Concorrência </p>  <p> * Agora, você provavelmente está pensando: "Eu posso ter melhor rendimento, quebrando o meu problema e deixando vários fluxos trabalharem sobre estas partes“ </p>  <p> * Infelizmente, os problemas raramente pode ser dividido em partes isoladas que podem ser executados totalmente independentes umas das outras – Muitas vezes, podemos executar algumas operações de forma independente, mas depois temos que mesclar os resultados parciais para obter o resultado final </p>  <p> * Isso requer que os fluxos comuniquem os resultados parciais e às vezes esperar por esses resultados para finalizar o trabalho </p>  <p> * Devemos possuir então, uma coordenação entre fluxos que pode levar a problemas de sincronização e bloqueio (deadlock)
 </p>  <p> * Starvation (inanição) – Ocorre inanição quando um processo nunca é executado ("morre de fome"), pois processos de prioridade maior sempre o impedem de ser executado
 </p>  <p> * Deadlock (interbloqueio, blocagem, impasse) – No contexto de sistemas operacionais, caracteriza uma situação em que ocorre um impasse e dois ou mais processos ficam impedidos de continuar suas execuções, ou seja, ficam bloqueados – Trata-se de um problema bastante estudado no contexto dos sistemas operacionais, assim como em outras disciplinas, como banco de dados, pois é inerente à própria natureza desses sistemas – O deadlock ocorre quando um ou mais processos está aguardando a liberação de um recurso por um outro processo que, por sua vez, aguarda a liberação de outro recurso alocado ou dependente do primeiro processo
 </p>  <p> * Condições de corrida (race conditions) – Se duas threads competem para usar o mesmo recurso ou dados, temos uma condição de corrida – A condição de corrida não acontecerão apenas quando dois fluxos modificam dados, também pode acontecer mesmo quando um está modificando dados, enquanto o outro está tentando acessá-lo – Condições de corrida pode tornar o comportamento de um programa imprevisível, produzir execução incorreta, e produzir resultados incorretos
 
### Referências 
  </p>  <p> * Wikipedia. Programação Concorrente. Acessado em: fev/2015. Disponível em: http://pt.wikipedia.org/wiki/ Programação_concorrente </p>  <p> * ALCHIERI, E. Programação Concorrente: Introdução. UNB. Acessado em: fev/2015. Disponível em: www.cic.unb.br/~alchieri/disciplinas/graduacao/pc/intro ducao.pdf </p>  <p> * TOSCANI, S. Programação Concorrente. PUCRS. Acessado em fev/2015. Disponível em: www.inf.pucrs.br/~ramos/ sop_progconctext.doc </p>  <p> * SUBRAMANIAM, V. Programming Concurrency on the JVM. The Pragmatic Bookshelf, 2011.
